- the exit status needs to be stored somewhere to get back to user

exit <- Running <-> ready <- init
              \      ^
               ,    /
              Blocked

Kernel: Queue just a place to wait! (Unordered or imposed order Bag)
- stored in kernel
Queues are called FIFOs in Kernel
(Good luck!)

- scheduler decides which process goes next
- only one process can run per processor core


Process Table:
- table of pcbs (processor control block)
 - pcb: collection of all the states of a process

- privillage escelation attack to get root privilage
 ______________________ _____________________ ___________________________
| Process mannagement  |       Memory        |  file                     |
|______________________|_____________________|___________________________|
| Program counter IP   | Segment pointers    | root directory            |
| registers            | (.txt .data .stack) | Current working directory |
| (CPSW, stack,etc)    |                     | file discriptotrs         |
| priority             |                     | UID/GID                   |
| PID/PPID             |                     |                           |
| Process group        |                     |                           |
| process accounting   |                     |                           |
| process state        |                     |                           |
|______________________|_____________________|___________________________|

Containers overwrite the address of root
Process classification
- CPU bound (FAST)
 - scale with CPU
- IO bound (SLOW)
 - (most of programs we have codded)
 - user interactioon
 - user is slowing the process down
 - GPU bounds are actually I/O bounds
 ? can we halt the program unti we get an input interrupt
  + interrupt driven IO

* Oracle grid engine
- cluster
- SLURM
 - submit a job description file
 - FIFO ordered from start to completion
 - Multiplex with processes

Round Robin scheduling:
- go round about and pass the prcoess token to each process.
- Scan the whole queue

O(1) scheduler:
- Older scheduler
- big iron systems (main frames etc)
- replacement for linus scheduler (garbage scheduler)

CFS : completely fair scheduler
- equal ratio of resources available for all processes
- for n processes each get 1/n of available resources
- by adding processes, n+1 processes each get 1/(n+1)
- they get all of the resources for 1/nth of cpu "time"
- Job priority causes difficulties to this model
 - niceness factor: reduce the priorit of your job and ask for less CPU time
- 1 queue per priority class
- multi queue system

- Depending on the process it could be faster to use more, less powerful processors

