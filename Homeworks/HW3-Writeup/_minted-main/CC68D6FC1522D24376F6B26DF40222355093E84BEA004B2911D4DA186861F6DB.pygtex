\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{}}
\PYG{c}{\PYGZsh{} Block device driver configuration}
\PYG{c}{\PYGZsh{}}

menuconfig BLK\PYGZus{}DEV
        bool \PYG{l+s+s2}{"Block devices"}
        depends on BLOCK
        default y
        ---help---
          Say Y here to get to see options \PYG{k}{for }various different block device
          drivers. This option alone does not add any kernel code.

          If you say N, all options in this submenu will be skipped and disabled;
          only \PYG{k}{do }this \PYG{k}{if }you know what you are doing.

\PYG{k}{if }BLK\PYGZus{}DEV

config BLK\PYGZus{}DEV\PYGZus{}RD2
        tristate \PYG{l+s+s2}{"RD2 DRIVER TEST 10-03"}

config BLK\PYGZus{}DEV\PYGZus{}NULL\PYGZus{}BLK
        tristate \PYG{l+s+s2}{"Null test block driver"}

config BLK\PYGZus{}DEV\PYGZus{}FD
        tristate \PYG{l+s+s2}{"Normal floppy disk support"}
        depends on ARCH\PYGZus{}MAY\PYGZus{}HAVE\PYGZus{}PC\PYGZus{}FDC
        ---help---
          If you want to use the floppy disk drive\PYG{o}{(}s\PYG{o}{)} of your PC under Linux,
          say Y. Information about this driver, especially important \PYG{k}{for }IBM
          Thinkpad users, is contained in
          <file:Documentation/blockdev/floppy.txt>.
          That file also contains the location of the Floppy driver FAQ as
          well as location of the fdutils package used to configure additional
          parameters of the driver at run time.

          To compile this driver as a module, choose M here: the
          module will be called floppy.

config AMIGA\PYGZus{}FLOPPY
        tristate \PYG{l+s+s2}{"Amiga floppy support"}
        depends on AMIGA

config ATARI\PYGZus{}FLOPPY
        tristate \PYG{l+s+s2}{"Atari floppy support"}
        depends on ATARI

config MAC\PYGZus{}FLOPPY
        tristate \PYG{l+s+s2}{"Support for PowerMac floppy"}
        depends on PPC\PYGZus{}PMAC \PYG{o}{&&} !PPC\PYGZus{}PMAC64
        \PYG{n+nb}{help}
\PYG{n+nb}{          }If you have a SWIM-3 \PYG{o}{(}Super Woz Integrated Machine 3; from Apple\PYG{o}{)}
          floppy controller, say Y here. Most commonly found in PowerMacs.

config BLK\PYGZus{}DEV\PYGZus{}SWIM
        tristate \PYG{l+s+s2}{"Support for SWIM Macintosh floppy"}
        depends on M68K \PYG{o}{&&} MAC
        \PYG{n+nb}{help}
\PYG{n+nb}{          }You should \PYG{k}{select }this option \PYG{k}{if }you want floppy support
          and you don\PYG{l+s+s1}{'t have a II, IIfx, Q900, Q950 or AV series.}

\PYG{l+s+s1}{config AMIGA\PYGZus{}Z2RAM}
\PYG{l+s+s1}{        tristate "Amiga Zorro II ramdisk support"}
\PYG{l+s+s1}{        depends on ZORRO}
\PYG{l+s+s1}{        help}
\PYG{l+s+s1}{          This enables support for using Chip RAM and Zorro II RAM as a}
\PYG{l+s+s1}{          ramdisk or as a swap partition. Say Y if you want to include this}
\PYG{l+s+s1}{          driver in the kernel.}

\PYG{l+s+s1}{          To compile this driver as a module, choose M here: the}
\PYG{l+s+s1}{          module will be called z2ram.}

\PYG{l+s+s1}{config GDROM}
\PYG{l+s+s1}{        tristate "SEGA Dreamcast GD-ROM drive"}
\PYG{l+s+s1}{        depends on SH\PYGZus{}DREAMCAST}
\PYG{l+s+s1}{        help}
\PYG{l+s+s1}{          A standard SEGA Dreamcast comes with a modified CD ROM drive called a}
\PYG{l+s+s1}{          "GD-ROM" by SEGA to signify it is capable of reading special disks}
\PYG{l+s+s1}{          with up to 1 GB of data. This drive will also read standard CD ROM}
\PYG{l+s+s1}{          disks. Select this option to access any disks in your GD ROM drive.}
\PYG{l+s+s1}{          Most users will want to say "Y" here.}
\PYG{l+s+s1}{          You can also build this as a module which will be called gdrom.}

\PYG{l+s+s1}{config PARIDE}
\PYG{l+s+s1}{        tristate "Parallel port IDE device support"}
\PYG{l+s+s1}{        depends on PARPORT\PYGZus{}PC}
\PYG{l+s+s1}{        ---help---}
\PYG{l+s+s1}{          There are many external CD-ROM and disk devices that connect through}
\PYG{l+s+s1}{          your computer'}s parallel port. Most of them are actually IDE devices
          using a parallel port IDE adapter. This option enables the PARIDE
          subsystem which contains drivers \PYG{k}{for }many of these external drives.
          Read <file:Documentation/blockdev/paride.txt> \PYG{k}{for }more information.

          If you have said Y to the \PYG{l+s+s2}{"Parallel-port support"} configuration
          option, you may share a single port between your printer and other
          parallel port devices. Answer Y to build PARIDE support into your
          kernel, or M \PYG{k}{if }you would like to build it as a loadable module. If
          your parallel port support is in a loadable module, you must build
          PARIDE as a module. If you built PARIDE support into your kernel,
          you may still build the individual protocol modules and high-level
          drivers as loadable modules. If you build this support as a module,
          it will be called paride.

          To use the PARIDE support, you must say Y or M here and also to at
          least one high-level driver \PYG{o}{(}e.g. \PYG{l+s+s2}{"Parallel port IDE disks"},
          \PYG{l+s+s2}{"Parallel port ATAPI CD-ROMs"}, \PYG{l+s+s2}{"Parallel port ATAPI disks"} etc.\PYG{o}{)} and
          to at least one protocol driver \PYG{o}{(}e.g. \PYG{l+s+s2}{"ATEN EH-100 protocol"},
          \PYG{l+s+s2}{"MicroSolutions backpack protocol"}, \PYG{l+s+s2}{"DataStor Commuter protocol"}
          etc.\PYG{o}{)}.

\PYG{n+nb}{source} \PYG{l+s+s2}{"drivers/block/paride/Kconfig"}

\PYG{n+nb}{source} \PYG{l+s+s2}{"drivers/block/mtip32xx/Kconfig"}

\PYG{n+nb}{source} \PYG{l+s+s2}{"drivers/block/zram/Kconfig"}

config BLK\PYGZus{}CPQ\PYGZus{}DA
        tristate \PYG{l+s+s2}{"Compaq SMART2 support"}
        depends on PCI \PYG{o}{&&} VIRT\PYGZus{}TO\PYGZus{}BUS \PYG{o}{&&} 0
        \PYG{n+nb}{help}
\PYG{n+nb}{          }This is the driver \PYG{k}{for }Compaq Smart Array controllers.  Everyone
          using these boards should say Y here.  See the file
          <file:Documentation/blockdev/cpqarray.txt> \PYG{k}{for }the current list of
          boards supported by this driver, and \PYG{k}{for }further information on the
          use of this driver.

config BLK\PYGZus{}CPQ\PYGZus{}CISS\PYGZus{}DA
        tristate \PYG{l+s+s2}{"Compaq Smart Array 5xxx support"}
        depends on PCI
        \PYG{k}{select }CHECK\PYGZus{}SIGNATURE
        \PYG{n+nb}{help}
\PYG{n+nb}{          }This is the driver \PYG{k}{for }Compaq Smart Array 5xxx controllers.
          Everyone using these boards should say Y here.
          See <file:Documentation/blockdev/cciss.txt> \PYG{k}{for }the current list of
          boards supported by this driver, and \PYG{k}{for }further information
          on the use of this driver.

config CISS\PYGZus{}SCSI\PYGZus{}TAPE
        bool \PYG{l+s+s2}{"SCSI tape drive support for Smart Array 5xxx"}
        depends on BLK\PYGZus{}CPQ\PYGZus{}CISS\PYGZus{}DA \PYG{o}{&&} PROC\PYGZus{}FS
        depends on \PYG{n+nv}{SCSI}\PYG{o}{=}y \PYG{o}{||} \PYG{n+nv}{SCSI}\PYG{o}{=}BLK\PYGZus{}CPQ\PYGZus{}CISS\PYGZus{}DA
        \PYG{n+nb}{help}
\PYG{n+nb}{          }When enabled \PYG{o}{(}Y\PYG{o}{)}, this option allows SCSI tape drives and SCSI medium
          changers \PYG{o}{(}tape robots\PYG{o}{)} to be accessed via a Compaq 5xxx array
          controller.  \PYG{o}{(}See <file:Documentation/blockdev/cciss.txt> \PYG{k}{for }more details.\PYG{o}{)}

          \PYG{l+s+s2}{"SCSI support"} and \PYG{l+s+s2}{"SCSI tape support"} must also be enabled \PYG{k}{for }this
          option to work.

          When this option is disabled \PYG{o}{(}N\PYG{o}{)}, the SCSI portion of the driver
          is not compiled.

config BLK\PYGZus{}DEV\PYGZus{}DAC960
        tristate \PYG{l+s+s2}{"Mylex DAC960/DAC1100 PCI RAID Controller support"}
        depends on PCI
        \PYG{n+nb}{help}
\PYG{n+nb}{          }This driver adds support \PYG{k}{for }the Mylex DAC960, AcceleRAID, and
          eXtremeRAID PCI RAID controllers.  See the file
          <file:Documentation/blockdev/README.DAC960> \PYG{k}{for }further information
          about this driver.

          To compile this driver as a module, choose M here: the
          module will be called DAC960.

config BLK\PYGZus{}DEV\PYGZus{}UMEM
        tristate \PYG{l+s+s2}{"Micro Memory MM5415 Battery Backed RAM support"}
        depends on PCI
        ---help---
          Saying Y here will include support \PYG{k}{for }the MM5415 family of
          battery backed \PYG{o}{(}Non-volatile\PYG{o}{)} RAM cards.
          <http://www.umem.com/>

          The cards appear as block devices that can be partitioned into
          as many as 15 partitions.

          To compile this driver as a module, choose M here: the
          module will be called umem.

          The umem driver has not yet been allocated a MAJOR number, so
          one is chosen dynamically.

config BLK\PYGZus{}DEV\PYGZus{}UBD
        bool \PYG{l+s+s2}{"Virtual block device"}
        depends on UML
        ---help---
          The User-Mode Linux port includes a driver called UBD which will \PYG{n+nb}{let}
\PYG{n+nb}{          }you access arbitrary files on the host computer as block devices.
          Unless you know that you \PYG{k}{do }not need such virtual block devices say
          Y here.

config BLK\PYGZus{}DEV\PYGZus{}UBD\PYGZus{}SYNC
        bool \PYG{l+s+s2}{"Always do synchronous disk IO for UBD"}
        depends on BLK\PYGZus{}DEV\PYGZus{}UBD
        ---help---
          Writes to the virtual block device are not immediately written to the
          host\PYG{l+s+s1}{'s disk; this may cause problems if, for example, the User-Mode}
\PYG{l+s+s1}{          Linux '}Virtual Machine\PYG{l+s+s1}{' uses a journalling filesystem and the host}
\PYG{l+s+s1}{          computer crashes.}

\PYG{l+s+s1}{          Synchronous operation (i.e. always writing data to the host'}s disk
          immediately\PYG{o}{)} is configurable on a per-UBD basis by using a special
          kernel \PYG{n+nb}{command }line option.  Alternatively, you can say Y here to
          turn on synchronous operation by default \PYG{k}{for }all block devices.

          If you\PYG{l+s+s1}{'re running a journalling file system (like reiserfs, for}
\PYG{l+s+s1}{          example) in your virtual machine, you will want to say Y here.  If}
\PYG{l+s+s1}{          you care for the safety of the data in your virtual machine, Y is a}
\PYG{l+s+s1}{          wise choice too.  In all other cases (for example, if you'}re just
          playing around with User-Mode Linux\PYG{o}{)} you can choose N.

config BLK\PYGZus{}DEV\PYGZus{}COW\PYGZus{}COMMON
        bool
        default BLK\PYGZus{}DEV\PYGZus{}UBD

config BLK\PYGZus{}DEV\PYGZus{}LOOP
        tristate \PYG{l+s+s2}{"Loopback device support"}
        ---help---
          Saying Y here will allow you to use a regular file as a block
          device; you can \PYG{k}{then }create a file system on that block device and
          mount it just as you would mount other block devices such as hard
          drive partitions, CD-ROM drives or floppy drives. The loop devices
          are block special device files with major number 7 and typically
          called /dev/loop0, /dev/loop1 etc.

          This is useful \PYG{k}{if }you want to check an ISO 9660 file system before
          burning the CD, or \PYG{k}{if }you want to use floppy images without first
          writing them to floppy. Furthermore, some Linux distributions avoid
          the need \PYG{k}{for }a dedicated Linux partition by keeping their \PYG{n+nb}{complete}
\PYG{n+nb}{          }root file system inside a DOS FAT file using this loop device
          driver.

          To use the loop device, you need the losetup utility, found in the
          util-linux package, see
          <ftp://ftp.kernel.org/pub/linux/utils/util-linux/>.

          The loop device driver can also be used to \PYG{l+s+s2}{"hide"} a file system in
          a disk partition, floppy, or regular file, either using encryption
          \PYG{o}{(}scrambling the data\PYG{o}{)} or steganography \PYG{o}{(}hiding the data in the low
          bits of, say, a sound file\PYG{o}{)}. This is also safe \PYG{k}{if }the file resides
          on a remote file server.

          There are several ways of encrypting disks. Some of these require
          kernel patches. The vanilla kernel offers the cryptoloop option
          and a Device Mapper target \PYG{o}{(}which is superior, as it supports all
          file systems\PYG{o}{)}. If you want to use the cryptoloop, say Y to both
          LOOP and CRYPTOLOOP, and make sure you have a recent \PYG{o}{(}version 2.12
          or later\PYG{o}{)} version of util-linux. Additionally, be aware that
          the cryptoloop is not safe \PYG{k}{for }storing journaled filesystems.

          Note that this loop device has nothing to \PYG{k}{do }with the loopback
          device used \PYG{k}{for }network connections from the machine to itself.

          To compile this driver as a module, choose M here: the
          module will be called loop.

          Most users will answer N here.

config BLK\PYGZus{}DEV\PYGZus{}LOOP\PYGZus{}MIN\PYGZus{}COUNT
        int \PYG{l+s+s2}{"Number of loop devices to pre-create at init time"}
        depends on BLK\PYGZus{}DEV\PYGZus{}LOOP
        default 8
        \PYG{n+nb}{help}
\PYG{n+nb}{          }Static number of loop devices to be unconditionally pre-created
          at init time.

          This default value can be overwritten on the kernel \PYG{n+nb}{command}
\PYG{n+nb}{          }line or with module-parameter loop.max\PYGZus{}loop.

          The historic default is 8. If a late 2011 version of losetup\PYG{o}{(}8\PYG{o}{)}
          is used, it can be \PYG{n+nb}{set }to 0, since needed loop devices can be
          dynamically allocated with the /dev/loop-control interface.

config BLK\PYGZus{}DEV\PYGZus{}CRYPTOLOOP
        tristate \PYG{l+s+s2}{"Cryptoloop Support"}
        \PYG{k}{select }CRYPTO
        \PYG{k}{select }CRYPTO\PYGZus{}CBC
        depends on BLK\PYGZus{}DEV\PYGZus{}LOOP
        ---help---
          Say Y here \PYG{k}{if }you want to be able to use the ciphers that are
          provided by the CryptoAPI as loop transformation. This might be
          used as hard disk encryption.

          WARNING: This device is not safe \PYG{k}{for }journaled file systems like
          ext3 or Reiserfs. Please use the Device Mapper crypto module
          instead, which can be configured to be on-disk compatible with the
          cryptoloop device.

\PYG{n+nb}{source} \PYG{l+s+s2}{"drivers/block/drbd/Kconfig"}

config BLK\PYGZus{}DEV\PYGZus{}NBD
        tristate \PYG{l+s+s2}{"Network block device support"}
        depends on NET
        ---help---
          Saying Y here will allow your computer to be a client \PYG{k}{for }network
          block devices, i.e. it will be able to use block devices exported by
          servers \PYG{o}{(}mount file systems on them etc.\PYG{o}{)}. Communication between
          client and server works over TCP/IP networking, but to the client
          program this is hidden: it looks like a regular \PYG{n+nb}{local }file access to
          a block device special file such as /dev/nd0.

          Network block devices also allows you to run a block-device in
          userland \PYG{o}{(}making server and client physically the same computer,
          communicating using the loopback network device\PYG{o}{)}.

          Read <file:Documentation/blockdev/nbd.txt> \PYG{k}{for }more information,
          especially about where to find the server code, which runs in user
          space and does not need special kernel support.

          Note that this has nothing to \PYG{k}{do }with the network file systems NFS
          or Coda; you can say N here even \PYG{k}{if }you intend to use NFS or Coda.

          To compile this driver as a module, choose M here: the
          module will be called nbd.

          If unsure, say N.

config BLK\PYGZus{}DEV\PYGZus{}NVME
        tristate \PYG{l+s+s2}{"NVM Express block device"}
        depends on PCI
        ---help---
          The NVM Express driver is \PYG{k}{for }solid state drives directly
          connected to the PCI or PCI Express bus.  If you know you
          don\PYG{l+s+s1}{'t have one of these, it is safe to answer N.}

\PYG{l+s+s1}{          To compile this driver as a module, choose M here: the}
\PYG{l+s+s1}{          module will be called nvme.}

\PYG{l+s+s1}{config BLK\PYGZus{}DEV\PYGZus{}SKD}
\PYG{l+s+s1}{        tristate "STEC S1120 Block Driver"}
\PYG{l+s+s1}{        depends on PCI}
\PYG{l+s+s1}{        depends on 64BIT}
\PYG{l+s+s1}{        ---help---}
\PYG{l+s+s1}{        Saying Y or M here will enable support for the}
\PYG{l+s+s1}{        STEC, Inc. S1120 PCIe SSD.}

\PYG{l+s+s1}{        Use device /dev/skd\PYGZdl{}N amd /dev/skd\PYGZdl{}Np\PYGZdl{}M.}

\PYG{l+s+s1}{config BLK\PYGZus{}DEV\PYGZus{}OSD}
\PYG{l+s+s1}{        tristate "OSD object-as-blkdev support"}
\PYG{l+s+s1}{        depends on SCSI\PYGZus{}OSD\PYGZus{}ULD}
\PYG{l+s+s1}{        ---help---}
\PYG{l+s+s1}{          Saying Y or M here will allow the exporting of a single SCSI}
\PYG{l+s+s1}{          OSD (object-based storage) object as a Linux block device.}

\PYG{l+s+s1}{          For example, if you create a 2G object on an OSD device,}
\PYG{l+s+s1}{          you can then use this module to present that 2G object as}
\PYG{l+s+s1}{          a Linux block device.}

\PYG{l+s+s1}{          To compile this driver as a module, choose M here: the}
\PYG{l+s+s1}{          module will be called osdblk.}

\PYG{l+s+s1}{          If unsure, say N.}

\PYG{l+s+s1}{config BLK\PYGZus{}DEV\PYGZus{}SX8}
\PYG{l+s+s1}{        tristate "Promise SATA SX8 support"}
\PYG{l+s+s1}{        depends on PCI}
\PYG{l+s+s1}{        ---help---}
\PYG{l+s+s1}{          Saying Y or M here will enable support for the}
\PYG{l+s+s1}{          Promise SATA SX8 controllers.}

\PYG{l+s+s1}{          Use devices /dev/sx8/\PYGZdl{}N and /dev/sx8/\PYGZdl{}Np\PYGZdl{}M.}

\PYG{l+s+s1}{config BLK\PYGZus{}DEV\PYGZus{}RAM}
\PYG{l+s+s1}{        tristate "RAM block device support"}
\PYG{l+s+s1}{        ---help---}
\PYG{l+s+s1}{          Saying Y here will allow you to use a portion of your RAM memory as}
\PYG{l+s+s1}{          a block device, so that you can make file systems on it, read and}
\PYG{l+s+s1}{          write to it and do all the other things that you can do with normal}
\PYG{l+s+s1}{          block devices (such as hard drives). It is usually used to load and}
\PYG{l+s+s1}{          store a copy of a minimal root file system off of a floppy into RAM}
\PYG{l+s+s1}{          during the initial install of Linux.}

\PYG{l+s+s1}{          Note that the kernel command line option "ramdisk=XX" is now obsolete.}
\PYG{l+s+s1}{          For details, read <file:Documentation/blockdev/ramdisk.txt>.}

\PYG{l+s+s1}{          To compile this driver as a module, choose M here: the}
\PYG{l+s+s1}{          module will be called brd. An alias "rd" has been defined}
\PYG{l+s+s1}{          for historical reasons.}

\PYG{l+s+s1}{          Most normal users won'}t need the RAM disk functionality, and can
          thus say N here.

config BLK\PYGZus{}DEV\PYGZus{}RAM\PYGZus{}COUNT
        int \PYG{l+s+s2}{"Default number of RAM disks"}
        default \PYG{l+s+s2}{"16"}
        depends on BLK\PYGZus{}DEV\PYGZus{}RAM
        \PYG{n+nb}{help}
\PYG{n+nb}{          }The default value is 16 RAM disks. Change this \PYG{k}{if }you know what you
          are doing. If you boot from a filesystem that needs to be extracted
          in memory, you will need at least one RAM disk \PYG{o}{(}e.g. root on cramfs\PYG{o}{)}.

config BLK\PYGZus{}DEV\PYGZus{}RAM\PYGZus{}SIZE
        int \PYG{l+s+s2}{"Default RAM disk size (kbytes)"}
        depends on BLK\PYGZus{}DEV\PYGZus{}RAM
        default \PYG{l+s+s2}{"4096"}
        \PYG{n+nb}{help}
\PYG{n+nb}{          }The default value is 4096 kilobytes. Only change this \PYG{k}{if }you know
          what you are doing.

config BLK\PYGZus{}DEV\PYGZus{}XIP
        bool \PYG{l+s+s2}{"Support XIP filesystems on RAM block device"}
        depends on BLK\PYGZus{}DEV\PYGZus{}RAM
        default n
        \PYG{n+nb}{help}
\PYG{n+nb}{          }Support XIP filesystems \PYG{o}{(}such as ext2 with XIP support on\PYG{o}{)} on
          top of block ram device. This will slightly enlarge the kernel, and
          will prevent RAM block device backing store memory from being
          allocated from highmem \PYG{o}{(}only a problem \PYG{k}{for }highmem systems\PYG{o}{)}.

config CDROM\PYGZus{}PKTCDVD
        tristate \PYG{l+s+s2}{"Packet writing on CD/DVD media"}
        depends on !UML
        \PYG{n+nb}{help}
\PYG{n+nb}{          }If you have a CDROM/DVD drive that supports packet writing, say
          Y to include support. It should work with any MMC/Mt Fuji
          compliant ATAPI or SCSI drive, which is just about any newer
          DVD/CD writer.

          Currently only writing to CD-RW, DVD-RW, DVD+RW and DVDRAM discs
          is possible.
          DVD-RW disks must be in restricted overwrite mode.

          See the file <file:Documentation/cdrom/packet-writing.txt>
          \PYG{k}{for }further information on the use of this driver.

          To compile this driver as a module, choose M here: the
          module will be called pktcdvd.

config CDROM\PYGZus{}PKTCDVD\PYGZus{}BUFFERS
        int \PYG{l+s+s2}{"Free buffers for data gathering"}
        depends on CDROM\PYGZus{}PKTCDVD
        default \PYG{l+s+s2}{"8"}
        \PYG{n+nb}{help}
\PYG{n+nb}{          }This controls the maximum number of active concurrent packets. More
          concurrent packets can increase write performance, but also require
          more memory. Each concurrent packet will require approximately 64Kb
          of non-swappable kernel memory, memory which will be allocated when
          a disc is opened \PYG{k}{for }writing.

config CDROM\PYGZus{}PKTCDVD\PYGZus{}WCACHE
        bool \PYG{l+s+s2}{"Enable write caching"}
        depends on CDROM\PYGZus{}PKTCDVD
        \PYG{n+nb}{help}
\PYG{n+nb}{          }If enabled, write caching will be \PYG{n+nb}{set }\PYG{k}{for }the CD-R/W device. For now
          this option is dangerous unless the CD-RW media is known good, as we
          don\PYG{l+s+s1}{'t do deferred write error handling yet.}

\PYG{l+s+s1}{config ATA\PYGZus{}OVER\PYGZus{}ETH}
\PYG{l+s+s1}{        tristate "ATA over Ethernet support"}
\PYG{l+s+s1}{        depends on NET}
\PYG{l+s+s1}{        help}
\PYG{l+s+s1}{        This driver provides Support for ATA over Ethernet block}
\PYG{l+s+s1}{        devices like the Coraid EtherDrive (R) Storage Blade.}

\PYG{l+s+s1}{config MG\PYGZus{}DISK}
\PYG{l+s+s1}{        tristate "mGine mflash, gflash support"}
\PYG{l+s+s1}{        depends on ARM && GPIOLIB}
\PYG{l+s+s1}{        help}
\PYG{l+s+s1}{          mGine mFlash(gFlash) block device driver}

\PYG{l+s+s1}{config MG\PYGZus{}DISK\PYGZus{}RES}
\PYG{l+s+s1}{        int "Size of reserved area before MBR"}
\PYG{l+s+s1}{        depends on MG\PYGZus{}DISK}
\PYG{l+s+s1}{        default 0}
\PYG{l+s+s1}{        help}
\PYG{l+s+s1}{          Define size of reserved area that usually used for boot. Unit is KB.}
\PYG{l+s+s1}{          All of the block device operation will be taken this value as start}
\PYG{l+s+s1}{          offset}
\PYG{l+s+s1}{          Examples:}
\PYG{l+s+s1}{                        1024 => 1 MB}

\PYG{l+s+s1}{config SUNVDC}
\PYG{l+s+s1}{        tristate "Sun Virtual Disk Client support"}
\PYG{l+s+s1}{        depends on SUN\PYGZus{}LDOMS}
\PYG{l+s+s1}{        help}
\PYG{l+s+s1}{          Support for virtual disk devices as a client under Sun}
\PYG{l+s+s1}{          Logical Domains.}

\PYG{l+s+s1}{source "drivers/s390/block/Kconfig"}

\PYG{l+s+s1}{config XILINX\PYGZus{}SYSACE}
\PYG{l+s+s1}{        tristate "Xilinx SystemACE support"}
\PYG{l+s+s1}{        depends on 4xx || MICROBLAZE}
\PYG{l+s+s1}{        help}
\PYG{l+s+s1}{          Include support for the Xilinx SystemACE CompactFlash interface}

\PYG{l+s+s1}{config XEN\PYGZus{}BLKDEV\PYGZus{}FRONTEND}
\PYG{l+s+s1}{        tristate "Xen virtual block device support"}
\PYG{l+s+s1}{        depends on XEN}
\PYG{l+s+s1}{        default y}
\PYG{l+s+s1}{        select XEN\PYGZus{}XENBUS\PYGZus{}FRONTEND}
\PYG{l+s+s1}{        help}
\PYG{l+s+s1}{          This driver implements the front-end of the Xen virtual}
\PYG{l+s+s1}{          block device driver.  It communicates with a back-end driver}
\PYG{l+s+s1}{          in another domain which drives the actual block device.}

\PYG{l+s+s1}{config XEN\PYGZus{}BLKDEV\PYGZus{}BACKEND}
\PYG{l+s+s1}{        tristate "Xen block-device backend driver"}
\PYG{l+s+s1}{        depends on XEN\PYGZus{}BACKEND}
\PYG{l+s+s1}{        help}
\PYG{l+s+s1}{          The block-device backend driver allows the kernel to export its}
\PYG{l+s+s1}{          block devices to other guests via a high-performance shared-memory}
\PYG{l+s+s1}{          interface.}

\PYG{l+s+s1}{          The corresponding Linux frontend driver is enabled by the}
\PYG{l+s+s1}{          CONFIG\PYGZus{}XEN\PYGZus{}BLKDEV\PYGZus{}FRONTEND configuration option.}

\PYG{l+s+s1}{          The backend driver attaches itself to a any block device specified}
\PYG{l+s+s1}{          in the XenBus configuration. There are no limits to what the block}
\PYG{l+s+s1}{          device as long as it has a major and minor.}

\PYG{l+s+s1}{          If you are compiling a kernel to run in a Xen block backend driver}
\PYG{l+s+s1}{          domain (often this is domain 0) you should say Y here. To}
\PYG{l+s+s1}{          compile this driver as a module, chose M here: the module}
\PYG{l+s+s1}{          will be called xen-blkback.}


\PYG{l+s+s1}{config VIRTIO\PYGZus{}BLK}
\PYG{l+s+s1}{        tristate "Virtio block driver"}
\PYG{l+s+s1}{        depends on VIRTIO}
\PYG{l+s+s1}{        ---help---}
\PYG{l+s+s1}{          This is the virtual block driver for virtio.  It can be used with}
\PYG{l+s+s1}{          lguest or QEMU based VMMs (like KVM or Xen).  Say Y or M.}

\PYG{l+s+s1}{config BLK\PYGZus{}DEV\PYGZus{}HD}
\PYG{l+s+s1}{        bool "Very old hard disk (MFM/RLL/IDE) driver"}
\PYG{l+s+s1}{        depends on HAVE\PYGZus{}IDE}
\PYG{l+s+s1}{        depends on !ARM || ARCH\PYGZus{}RPC || BROKEN}
\PYG{l+s+s1}{        help}
\PYG{l+s+s1}{          This is a very old hard disk driver that lacks the enhanced}
\PYG{l+s+s1}{          functionality of the newer ones.}

\PYG{l+s+s1}{          It is required for systems with ancient MFM/RLL/ESDI drives.}

\PYG{l+s+s1}{          If unsure, say N.}

\PYG{l+s+s1}{config BLK\PYGZus{}DEV\PYGZus{}RBD}
\PYG{l+s+s1}{        tristate "Rados block device (RBD)"}
\PYG{l+s+s1}{        depends on INET && BLOCK}
\PYG{l+s+s1}{        select CEPH\PYGZus{}LIB}
\PYG{l+s+s1}{        select LIBCRC32C}
\PYG{l+s+s1}{        select CRYPTO\PYGZus{}AES}
\PYG{l+s+s1}{        select CRYPTO}
\PYG{l+s+s1}{        default n}
\PYG{l+s+s1}{        help}
\PYG{l+s+s1}{          Say Y here if you want include the Rados block device, which stripes}
\PYG{l+s+s1}{          a block device over objects stored in the Ceph distributed object}
\PYG{l+s+s1}{          store.}

\PYG{l+s+s1}{          More information at http://ceph.newdream.net/.}

\PYG{l+s+s1}{          If unsure, say N.}

\PYG{l+s+s1}{config BLK\PYGZus{}DEV\PYGZus{}RSXX}
\PYG{l+s+s1}{        tristate "IBM Flash Adapter 900GB Full Height PCIe Device Driver"}
\PYG{l+s+s1}{        depends on PCI}
\PYG{l+s+s1}{        help}
\PYG{l+s+s1}{          Device driver for IBM'}s high speed PCIe SSD
          storage device: Flash Adapter 900GB Full Height.

          To compile this driver as a module, choose M here: the
          module will be called rsxx.

endif \PYG{c}{\PYGZsh{} BLK\PYGZus{}DEV}
\end{Verbatim}
